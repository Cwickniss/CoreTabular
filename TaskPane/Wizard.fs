module Wizard

open MicrosoftResearch.Infer.Tabular
open MicrosoftResearch.Infer.Tabular.CrossValidation
open MicrosoftResearch.Infer.Tabular.DataLayer
open MicrosoftResearch.Infer.Tabular.DataLayer.ExcelNames
open Microsoft.Office.Interop
//open MicrosoftResearch.Infer.Tabular.DataLayer.NewIO
module NewTabular = Syntax
open NewTabular
open MicrosoftResearch.Infer.Distributions
//open MicrosoftResearch.Infer.Tabular.Plates



// create extra tables ------------------------------------------------
//let getNumRowsColumns ((colmap,data):dataNormalized) = 
//    let numCols = colmap.Count
//    let numRows = Seq.length data
//    numRows, numCols
//
//let getNumRowsColumnsInDTO (DTO(dto)) = 
//    let numRows, numCols = Map.fold (fun (nRcum, nCcum) _ dn -> 
//                                        let extraRowsPerTable, extraColsPerTable = 2, 1
//                                        let nR, nC = getNumRowsColumns dn
//                                        nRcum + nR + extraRowsPerTable, nCcum + nC + extraColsPerTable
//                                    ) (1,1) dto // one additional extra column and row spacing
//    numRows, numCols


/// go to the leftmost column that has enough empty cells to hold numRows rows (and numCols columns wide)
let getNextEmptyRange (ws:Excel.Worksheet) numRows numCols = 
    (Seq.skipWhile (fun (r:Excel.Range) -> not r.allBlank)
                  (Seq.initInfinite (fun idx -> ws.Range(cte (idx+1,1), cte (idx+numCols + 1,numRows)) )) // try starting from column 1, 2, 3, ... until whole range can fit
    |> Seq.head).selectSubRng(topcol=2) // extra padding of one column 
    


/// helper function to find all the connections that refer to tname either in primary or foreign key
let getConnectionsForTable (wb:Excel.Workbook) (tname:TableName) = 
    let enum = wb.Connections.GetEnumerator()
    let mutable list = [] // build a list
    while enum.MoveNext() do // iterate through all connections
        match enum.Current with
        | :? Excel.WorkbookConnection as con -> // look for the WorkbookConnections
            try
                let wdc = con.WorksheetDataConnection
                let constr = wdc.CommandText :?> string
                /// either a range or a table.  This is "#REF!" if its reference has been deleted.
                let contarget = constr.IndexOf('!') |> (+) 1 |> constr.TrimEnd(' ').Substring 
                if contarget.Equals(tname)
                then list <- con :: list
            with 
                |e -> ()
        | _ -> ()
    list

/// might come in handy; get all bad connections
let getErrorConnections wb = getConnectionsForTable wb "#REF!"

/// write a single table to a sheet
let writeTableToSheetAndMakeTable (wb:Excel.Workbook) (ws:Excel.Worksheet) (tname:TableName) ((colmap,data) as dn:dataNormalized) :Excel.ListObject = 
    // does a ListObject already exist? Yes --> delete it and overwrite
    try
        let lo = ws.ListObjects.Item(tname) // throws exception if table does not exist

        // if the table exists, first delete all worksheet connections from this table
        getConnectionsForTable wb tname |> List.iter (fun con -> con.Delete())
        
        lo.Range.selectSubRng(botrow=1).Offset(-1,0).Clear() |> ignore
        lo.Delete()
    with 
        | :? System.Runtime.InteropServices.COMException as e -> () // table does not exist

    // how many rows and columns do we need?
    let nC = colmap.Count
    let nR = Seq.length data + 2 // number of actual rows + column label row + table label row
    // get fresh range
    let rng = getNextEmptyRange ws nR nC
    // first write the table name
    do  
        let tableNameCell = rng.Item(1,1):?>Excel.Range
        tableNameCell.Value2 <- tname //.selectSubRng(toprow=1,botrow=1)
        tableNameCell.Font.Bold <- true
    // write column names
    do
        let colRng = rng.selectSubRng(toprow=2,botrow=2)
        Map.iter (fun colname idx -> (colRng.Item(1,idx+1):?>Excel.Range).Value2 <- colname) (colmap) // rng.selectSubRng(toprow=2,botrow=2,topcol=(idx+1),botcol=(idx+1))
    // write table values
    do
        let dataRng = rng.selectSubRng(toprow=3)
        Seq.iteri (fun idx objarr -> 
                        let subrng = dataRng.selectSubRng(toprow=(1+idx),botrow=(1+idx)(*,topcol=1,botcol=(Array.length objarr)*))
                        subrng.Value2 <- objarr 
                        ()
                  ) (data)
    // make a new ListObject
    let tableRng = rng.selectSubRng(toprow=2)
    let lo = ws.ListObjects.Add(SourceType=Excel.XlListObjectSourceType.xlSrcRange,
                                Source=tableRng,
                                XlListObjectHasHeaders=Excel.XlYesNoGuess.xlYes)
    lo.Name <- tname
    //lo.DisplayName <- tname
    lo.Comment <- "Table "+tname+"; autogenerated by Tabular ModelWizard"
    lo

/// write a bunch of tables to a spreadsheet, starting from the left
let writeDTOToSheetAndMakeTable (wb:Excel.Workbook) (ws:Excel.Worksheet) (DTO(dto)) : Map<TableName,Excel.ListObject> = 
    Map.map (writeTableToSheetAndMakeTable wb ws) dto

/// add a list object (called a Table) to the datamodel
let addListObjectToDataModel (wb:Excel.Workbook) (lo:Excel.ListObject) =
    let cons = wb.Connections
    let fullpath = wb.FullName
    // Be careful with the table name!  Weird characters may mess it up.
    try
        let wcon_new = cons.Add2(lo.Name,
                            lo.DisplayName+"; added by Tabular ModelWizard",
                            "WORKSHEET;"+fullpath, // format: "WORKSHEET;\\path\to\file\testDataModel.xlsx",
                            wb.Name+"!"+lo.Name,   // format: testDataModel.xlsx!Table1",
                            Excel.XlCmdType.xlCmdExcel, true, true)
        ()
    with
        |e -> System.Console.WriteLine("Failed to create connection to table "+(lo.Name))
    ()

let createModelRelationship (model:Excel.Model) (tnameFK:TableName, cnameFK:ColumnName) (tnamePK:TableName, cnamePK:ColumnName) =
    try
        //model.Refresh()
        Async.Sleep(5000) |> ignore // NEED MODEL TO FINISH UPDATING AFTER AN ADD
        let mtcFK = model.ModelTables.Item(tnameFK).ModelTableColumns.Item(cnameFK)
        let mtcPK = model.ModelTables.Item(tnamePK).ModelTableColumns.Item(cnamePK)
        model.ModelRelationships.Add(mtcFK,mtcPK)
    with
        |e -> //eprintf "%s" <| "Warning: unable to create relationship from "+tnameFK+":"+cnameFK+" to "+tnamePK+":"+cnamePK  //raise e
              System.Console.WriteLine( sprintf "Failed to create relationship; FK(%s:%s) -> PK(%s:%s)" tnameFK cnameFK tnamePK cnamePK )
              null  // bad return...


let sClassifierTable = "classifier_table" :TableName

/// prefix prepended to newly created tables of unique values
let sTablePrefix = "T_"

/// name of Tabular shadow sheet to put extra tables
let sShadowSheet = "Shadow_Tabular"
let putExtraTables_shadow (wb:Excel.Workbook) (DTO(dto)) =
    let ws =    try 
                    wb.Worksheets.Item(sShadowSheet) :?> Excel.Worksheet
                with
                    |e ->   let ws = wb.Worksheets.Add(Type=Excel.XlSheetType.xlWorksheet) :?> Excel.Worksheet 
                            ws.Name <- sShadowSheet
                            ws.Visible <- Excel.XlSheetVisibility.xlSheetHidden // want to have fun? Use xlSheetVeryHidden.
                            ws
    let lomap = writeDTOToSheetAndMakeTable wb ws (DTO(dto))
    // Do I need to refresh the model here?
    lomap //|> Map.toSeq |> Seq.take 2 
    |>    Map.iter (fun _ lo ->   
                            addListObjectToDataModel wb lo
                            // *** If the List Object name begins with "T_", say that the column is the list object name with that removed
                            let tnamePK = lo.Name
                            let cname = if lo.Name.[0..1].Equals(sTablePrefix)
                                        then lo.Name.Substring(2)
                                        else lo.Name
                            createModelRelationship (wb.Model) (sClassifierTable,cname) (tnamePK,cname) |> ignore // throw away the created relationship object
                   ) //lomap

    //failwith "nyi"

// table creation methods --------------------------------------------------------

/// dummy version: just says that every row is a discrete column
let selectDiscreteColumns_all ((colmap,data):dataNormalized) :Map<ColumnName,int> = 
    colmap

let getUniqueValues =  Seq.distinct
//    Seq.fold (fun uniqs newVal ->   match Seq.tryFind (fun o -> obj.Equals(newVal,o)) uniqs  with
//                                    |Some _ -> uniqs
//                                    |None -> Seq.append uniqs (Seq.singleton newVal)
//             ) Seq.empty data



/// is it the case that no two values are the same up to case insensitivity?
/// Returns one value each of the strings that are identical up to case and space (trimming) insensitivity
let checkCaseAndSpaceInsensitive uvs =
    let s2 = Seq.distinctBy (fun o -> o.ToString().ToUpperInvariant().Trim()) uvs
    if (Seq.length s2) = (Seq.length uvs)
    then Seq.empty
    else (Set.ofSeq uvs) - (Set.ofSeq s2) |> Set.toSeq
//    Seq.fold (fun uniqsUpper newVal ->  match Seq.tryFind (fun o -> System.String.Equals(o, newVal, System.StringComparison.OrdinalIgnoreCase) = 0 ) uniqsUpper  with
//                                        |Some _ -> uniqs
//                                        |None -> Seq.append uniqs (Seq.singleton newVal)
//             ) Seq.empty uvs
//    let s2 = uvs |> Seq.map (fun o -> o.ToString().ToUpper() :> obj) |> getUniqueValues
//    (Seq.length s2) = (Seq.length uvs)


let makeUniqueTable  (colname:ColumnName) (colidx:int) (coldata:seq<obj>) :(TableName * dataNormalized) =
    let colmap = Map.add colname 0 Map.empty
    let uniqueValues = coldata |> getUniqueValues 
                               |> Seq.filter (not << (=) null) // don't include nulls -- missing values

    // Bugfix: Excel data model considers two values that differ only case to be the same, e.g., "es" vs. "ES".
    // If this happens, convert all values to uppercase and warn the user.
    // The wizard will fail under these circumstances.
    let badVals = checkCaseAndSpaceInsensitive <| Seq.cast uniqueValues
    if badVals |> Seq.length |> (<>) 0
    then System.Console.WriteLine( "WARNING: The following values in column "+colname+" have duplicates with different cases or trailing/prevailing spaces. Making unique tables will likely fail. Please check the column to convert these to distinct values or to the same case and remove extra spaces: "
                                    + ( Seq.fold (fun accum v -> accum + " " + v.ToString()) "" badVals ) )

    let data = uniqueValues
               |> Seq.map (Array.create<obj> 1)
    sTablePrefix+colname, (colmap, data)






//  Naive Bayes Classifier generation ------------------------------------

/// computation expression: return false if and only if all heuristics fail
///   Stop computation and return true on the first yield expression returning true.
type OneTrueBuilder() =
//    member this.Bind(v,f) = 
//        if v then true
//        else f v
    member this.Zero () = false
    member this.Combine(b,f) = b || f()
    member this.Yield(b) = b
    member this.Delay(f) = f
    member this.Run(f) = f()

/// heuristically guess which columns should be considered discrete and split into a table of unique values
let selectDiscreteColumns_smart ((colmap,alldata):dataNormalized) :Map<ColumnName,int> = 
    Map.filter (fun colname colidx ->
                // test this column's data to see if it is likely a collection of discrete values we can split into a table of unique values
                let coldata = Seq.map (fun (objarr:obj[]) -> objarr.[colidx]) alldata

                not <| OneTrueBuilder() {
                    // qualifying heuristics: each one filters out whether we consider this column a discrete column. If one returns true, stop computation and filter out this column.
                    // heuristic 0: if the data can be parsed as a boolean, return false (heuristic fails to filter). Try on the first value. (Assume at least one row of data.)
                    let firstval = coldata |> Seq.head |> string
                    yield System.Boolean.TryParse (firstval, ref false)
                
                    // heuristic 1: if the data can be parsed as a number, return false (heuristic fails to filter).  Try on the first value. (Assume at least one row of data.)
                    yield System.Double.TryParse(firstval, ref 0.0)

                    // heuristic 2: if the data has < 0.6 * (# data points) unique values, then return false (heuristic fails to filter)
                    let uniqs = getUniqueValues coldata 
                    yield (Seq.length uniqs |> float) > 0.6 * (Seq.length coldata |> float)
                }
                ) colmap



let chooseClassifierTable_sClassifierTable (DTO(dto)) = 
    assert( Map.containsKey sClassifierTable dto ) // make sure the table is present
    sClassifierTable
    
    

/// Pick the first Column (at position 0); assumes at least one column
let chooseClassifierColumn_first ((colmap,_):dataNormalized) =
    Map.findKey (fun _ idx -> idx = 0) colmap, 0



// 





let  sCDiscrete = "CDiscrete"

let transformLinkedColumnNoIndex (oldClasscol:Column):Column = 
    // change: Occupation	link(T_Occupation)	input   --
    // to    : Occupation	link(T_Occupation)	output	CDiscrete(N=SizeOf(T_Occupation))
    let tableName = match oldClasscol.Type with
                    | (T_Det (B_Link tableName, _)) -> tableName
                    | _ -> failwith "not a linked column"
    {oldClasscol with Markup=Observable( MCall("CDiscrete",["N",SizeOf(tableName) ]) )}

let transformColumn (classcolName:ColumnName) (oldCol:Column) :Column =
    // match on type: 
    //  link -> CDiscrete on linked table 
    //  bool -> CBernoulli
    //  int,real -> real, CGaussian
    // todo: set hyperparams: MeanMean to empirical mean, precision appropriately?
    match oldCol.Type with
    | (T_Det (B_Bool, _)) -> {Type=T_Det(B_Bool,R); Markup=Observable( MIndexed(MCall("CBernoulli",[ (*hypers*) ]), Var classcolName, Const (IntConst -1)) )}
    | (T_Det (B_Int, _))
    | (T_Det (B_Real, _)) -> {Type=T_Det(B_Real,R); Markup=Observable( MIndexed(MCall("CGaussian",[ (*hypers*) ]), Var classcolName, Const (IntConst -1)) )}
    | (T_Det (B_Link tableName, _)) -> {Type=T_Det(B_Link tableName,R); Markup=Observable( MIndexed(MCall("CDiscrete",["N",SizeOf(tableName)]), Var classcolName, Const (IntConst -1)) )} // -1 means upper index bound inferred
    | _ -> oldCol
        

let generateClassifierSchema (rawSchema:Schema) :Schema = 
// assuming there exists a table called...
    
    // and that the column to classify is the FIRST column
    // for other columns, do different things depending on its type
        
    let oldClassifierTable = match rawSchema |> List.tryFind  (fun decl -> decl.Name.Equals(sClassifierTable)) with
        | Some x -> x.getTable
        | None -> failwith "Sorry could not find \"classifier_table\""

    let (classcolName, oldClasscol) = List.head oldClassifierTable // index by classcolName
    let newClasscol = transformLinkedColumnNoIndex oldClasscol

    let newClassifierTable = (classcolName, newClasscol):: (oldClassifierTable |> List.tail |> List.map ((fun (colname,col) -> (colname, col |> transformColumn classcolName)) ))
    // put classifier_table at end of list
    List.append (List.filter (fun decl -> not <| decl.Name.Equals(sClassifierTable)) rawSchema) [Declaration(Table(sClassifierTable,None),newClassifierTable)]










let wizNaiveBayesClassifier (wb:Excel.Workbook) (chooseClassifierTable: DTO -> TableName) (chooseClassifierColumn: dataNormalized -> ColumnName * int)
                            (putExtraTables: Excel.Workbook -> DTO -> unit) (selectDiscreteColumns: dataNormalized -> Map<ColumnName,int>) :Schema =
    // openPPForBug signals whether or not to open the PowerPivot data table
    /// does not have any new tables (unless from previous run)
    //let inputSchema = use loader = new ExcelLoader(wb,openPPForBug=false) :> NewIO.ILoader in loader.GetSchema()
    use loader = new DataModelLoader(wb,openPPForBug=false) :> NewIO.ILoader
    //let dicLog, dicIdStrategy, dicDatas, idToPos = readTable loader inputSchema
    let _,_, _, dtoInput, _, _, _ = readTable loader <| loader.GetSchema() // getSchema here returns the default schema of all inputs
    let classTable = DTO(dtoInput) |> chooseClassifierTable
    let classData = dtoInput |> Map.find classTable |> snd
    let classColname, classColidx = dtoInput.Item classTable |> chooseClassifierColumn
    let discreteCols = dtoInput.Item classTable |> selectDiscreteColumns
    let uniqueTables : Map<TableName,dataNormalized> = 
        Map.map (fun colname colidx -> 
            let coldata = Seq.map (fun (objarr:obj[]) -> objarr.[colidx]) classData
            let _, dn = makeUniqueTable colname colidx coldata 
            dn
        ) discreteCols 
        |> Map.toSeq
        |> Seq.map (fun (tname,dn) -> (sTablePrefix+tname,dn))
        |> Map.ofSeq

    // put unique tables in a shadow worksheet, add to data model, create relationships
    putExtraTables wb (DTO(uniqueTables))
    // create new schema as originally done
    generateClassifierSchema <|     loader.GetSchema() // loader sees the additional unique tables





    ////////////////////////////////////////////////////////////////////////////////////////////////////







